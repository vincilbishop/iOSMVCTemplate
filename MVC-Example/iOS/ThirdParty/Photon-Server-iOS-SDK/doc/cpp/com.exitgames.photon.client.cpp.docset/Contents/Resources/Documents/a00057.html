<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Exit Games Photon C++ Client Library: PhotonPeer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Exit Games Photon C++ Client Library
   &#160;<span id="projectnumber">3.2.5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00057.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="a00478.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PhotonPeer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for PhotonPeer:</div>
<div class="dyncontent">
<div class="center"><img src="a00479.gif" border="0" usemap="#_photon_peer_inherit__map" alt="Inheritance graph"/></div>
<map name="_photon_peer_inherit__map" id="_photon_peer_inherit__map">
<area shape="rect" id="node2" href="a00046.html" title="LitePeer" alt="" coords="4,81,64,106"/><area shape="rect" id="node3" href="a00055.html" title="Peer" alt="" coords="89,81,132,106"/><area shape="rect" id="node4" href="a00029.html" title="Client" alt="" coords="86,156,135,180"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add10663f1d2b78d17dbecc515a8f3155"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#add10663f1d2b78d17dbecc515a8f3155">PhotonPeer</a> (<a class="el" href="a00056.html">PhotonListener</a> &amp;listener, bool useTcp=false)</td></tr>
<tr class="separator:add10663f1d2b78d17dbecc515a8f3155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313f46953d3a15d0141f7d0bd5a8febe"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a313f46953d3a15d0141f7d0bd5a8febe">~PhotonPeer</a> (void)</td></tr>
<tr class="separator:a313f46953d3a15d0141f7d0bd5a8febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7744e8ff38ca12b4568a61d8ce5b42"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a3b7744e8ff38ca12b4568a61d8ce5b42">connect</a> (const <a class="el" href="a00041.html">Common::JString</a> &amp;ipAddr, const nByte appID[Internal::InternalProperties::APP_NAME_LENGTH]=NULL)</td></tr>
<tr class="separator:a3b7744e8ff38ca12b4568a61d8ce5b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888a5acf1fe3a8902f7cb2f5039cb334"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect</a> (void)</td></tr>
<tr class="separator:a888a5acf1fe3a8902f7cb2f5039cb334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66e8bb0fdc525c5e250092c35343a2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service</a> (bool <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands</a>=true)</td></tr>
<tr class="separator:ac66e8bb0fdc525c5e250092c35343a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29567202b6f36cf6805209c2299d912"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ab29567202b6f36cf6805209c2299d912">serviceBasic</a> (void)</td></tr>
<tr class="separator:ab29567202b6f36cf6805209c2299d912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1268775eba0cfe2b6f7e309a27e2fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a3c1268775eba0cfe2b6f7e309a27e2fd">opCustom</a> (const <a class="el" href="a00053.html">OperationRequest</a> &amp;operationRequest, bool sendReliable, nByte channelID=0, bool encrypt=false)</td></tr>
<tr class="separator:a3c1268775eba0cfe2b6f7e309a27e2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c40c416f4c106eaa3c0d21b5d1a440e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands</a> (void)</td></tr>
<tr class="separator:a8c40c416f4c106eaa3c0d21b5d1a440e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be00ecc71ec66c70629a9064d397d2b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands</a> (void)</td></tr>
<tr class="separator:a4be00ecc71ec66c70629a9064d397d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac22c1480ba011cf646db5a1038f63"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption</a> (void)</td></tr>
<tr class="separator:a65ac22c1480ba011cf646db5a1038f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e6e2243583f7cf42b8123e068302e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ab2e6e2243583f7cf42b8123e068302e9">fetchServerTimestamp</a> (void)</td></tr>
<tr class="separator:ab2e6e2243583f7cf42b8123e068302e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae114d96824d1db8e0411453b737d0c50"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00056.html">PhotonListener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ae114d96824d1db8e0411453b737d0c50">getListener</a> (void) const </td></tr>
<tr class="separator:ae114d96824d1db8e0411453b737d0c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa4e468a3ebed107a6963ae1e15f244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a6fa4e468a3ebed107a6963ae1e15f244">getServerTimeOffset</a> (void) const </td></tr>
<tr class="separator:a6fa4e468a3ebed107a6963ae1e15f244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d497df1e1e3189833ea9a92a94e4ab8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a0d497df1e1e3189833ea9a92a94e4ab8">getServerTime</a> (void) const </td></tr>
<tr class="separator:a0d497df1e1e3189833ea9a92a94e4ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c380f06cc1a08a040b29043504ee073"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a2c380f06cc1a08a040b29043504ee073">getBytesOut</a> (void) const </td></tr>
<tr class="separator:a2c380f06cc1a08a040b29043504ee073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51ec2106d45c47771b9623214a53765"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ac51ec2106d45c47771b9623214a53765">getBytesIn</a> (void) const </td></tr>
<tr class="separator:ac51ec2106d45c47771b9623214a53765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2341495102d474e47dfa8352cac466"><td class="memItemLeft" align="right" valign="top">PeerState::PeerState&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#aaa2341495102d474e47dfa8352cac466">getPeerState</a> (void) const </td></tr>
<tr class="separator:aaa2341495102d474e47dfa8352cac466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1062ff9979a3f5de11edb7432e954a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a4b1062ff9979a3f5de11edb7432e954a">getSentCountAllowance</a> (void) const </td></tr>
<tr class="separator:a4b1062ff9979a3f5de11edb7432e954a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75b3c4ebd0d1c85b9455cd7c97c85f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ae75b3c4ebd0d1c85b9455cd7c97c85f8">setSentCountAllowance</a> (int setSentCountAllowance)</td></tr>
<tr class="separator:ae75b3c4ebd0d1c85b9455cd7c97c85f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43122c10ff52a0a6b227c443b49671bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a43122c10ff52a0a6b227c443b49671bd">getTimePingInterval</a> (void) const </td></tr>
<tr class="separator:a43122c10ff52a0a6b227c443b49671bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96b54d2894633bf699bdf5b407bb486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ab96b54d2894633bf699bdf5b407bb486">setTimePingInterval</a> (int setTimePingInterval)</td></tr>
<tr class="separator:ab96b54d2894633bf699bdf5b407bb486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d58f9f28efef342eb2e6b5e90babc95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a3d58f9f28efef342eb2e6b5e90babc95">getRoundTripTime</a> (void) const </td></tr>
<tr class="separator:a3d58f9f28efef342eb2e6b5e90babc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fdc08e49473ab212a337a2602f01fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a45fdc08e49473ab212a337a2602f01fe">getRoundTripTimeVariance</a> (void) const </td></tr>
<tr class="separator:a45fdc08e49473ab212a337a2602f01fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164f59d83f8921f0466a666cb4db3eaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00248.html#ab658e6d84759440dbf3c890446075395">Common::DebugLevel::DebugLevel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a164f59d83f8921f0466a666cb4db3eaf">getDebugOutputLevel</a> (void) const </td></tr>
<tr class="memdesc:a164f59d83f8921f0466a666cb4db3eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#a164f59d83f8921f0466a666cb4db3eaf"></a><br/></td></tr>
<tr class="separator:a164f59d83f8921f0466a666cb4db3eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef1ecf21b7651217c62b279f879cc15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#abef1ecf21b7651217c62b279f879cc15">setDebugOutputLevel</a> (<a class="el" href="a00248.html#ab658e6d84759440dbf3c890446075395">Common::DebugLevel::DebugLevel</a> debugLevel)</td></tr>
<tr class="memdesc:abef1ecf21b7651217c62b279f879cc15"><td class="mdescLeft">&#160;</td><td class="mdescRight"> <a href="#abef1ecf21b7651217c62b279f879cc15"></a><br/></td></tr>
<tr class="separator:abef1ecf21b7651217c62b279f879cc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b40e4d8e9dd59483904727618c8a7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a85b40e4d8e9dd59483904727618c8a7f">getIncomingReliableCommandsCount</a> (void) const </td></tr>
<tr class="separator:a85b40e4d8e9dd59483904727618c8a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dae9746fea1efa33a84167808c59962"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a0dae9746fea1efa33a84167808c59962">getPeerId</a> (void) const </td></tr>
<tr class="separator:a0dae9746fea1efa33a84167808c59962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bdf2648a8ccfd9c83e0641b5663903"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ab6bdf2648a8ccfd9c83e0641b5663903">getDisconnectTimeout</a> (void) const </td></tr>
<tr class="separator:ab6bdf2648a8ccfd9c83e0641b5663903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9e8b780e386121f1b33b3f1c95c123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout</a> (int disconnectTimeout)</td></tr>
<tr class="separator:a9f9e8b780e386121f1b33b3f1c95c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de704871bf246a9f2a074fc524090c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a9de704871bf246a9f2a074fc524090c1">getQueuedIncomingCommands</a> (void) const </td></tr>
<tr class="separator:a9de704871bf246a9f2a074fc524090c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b26feaa1adf2eb401755cc181567ad0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a1b26feaa1adf2eb401755cc181567ad0">getQueuedOutgoingCommands</a> (void) const </td></tr>
<tr class="separator:a1b26feaa1adf2eb401755cc181567ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b12d1666e4c44dc9301a1c3de443bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00041.html">Common::JString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#ae1b12d1666e4c44dc9301a1c3de443bf">getServerAddress</a> (void) const </td></tr>
<tr class="separator:ae1b12d1666e4c44dc9301a1c3de443bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82e5be376f122cd0694474a2bf30df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#af82e5be376f122cd0694474a2bf30df3">getIsEncryptionAvailable</a> (void) const </td></tr>
<tr class="separator:af82e5be376f122cd0694474a2bf30df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a10359924120048ca6281db6ed9dda97d"><td class="memItemLeft" align="right" valign="top">static short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html#a10359924120048ca6281db6ed9dda97d">getPeerCount</a> (void)</td></tr>
<tr class="separator:a10359924120048ca6281db6ed9dda97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="a00057.html">PhotonPeer</a> class provides an API for reliable and unreliable realtime communication.</p>
<p><a class="el" href="a00057.html">PhotonPeer</a> uses the callback interface <a class="el" href="a00056.html">PhotonListener</a> that needs to be implemented by your application, to receive results and events from the <a class="el" href="a00276.html">Photon</a> Server. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="add10663f1d2b78d17dbecc515a8f3155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00057.html">PhotonPeer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00056.html">PhotonListener</a> &amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTcp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>Pointer to the application's implementation of the Listener callback interface. Has to be valid for at least the lifetime of the <a class="el" href="a00057.html">PhotonPeer</a> instance, which is created by this constructor. </td></tr>
    <tr><td class="paramname">useTcp</td><td>used for UDP/TCP switching. Use false for UDP and true for TCP (false by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00056.html">PhotonListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a313f46953d3a15d0141f7d0bd5a8febe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="a00057.html">PhotonPeer</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00057_a313f46953d3a15d0141f7d0bd5a8febe_cgraph.gif" border="0" usemap="#a00057_a313f46953d3a15d0141f7d0bd5a8febe_cgraph" alt=""/></div>
<map name="a00057_a313f46953d3a15d0141f7d0bd5a8febe_cgraph" id="a00057_a313f46953d3a15d0141f7d0bd5a8febe_cgraph">
<area shape="rect" id="node2" href="a00253.html#adab0c26ccee7949cb30a976e74be459b" title="ExitGames::Common::\lMemoryManagement::deallocate" alt="" coords="140,5,316,43"/></map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3b7744e8ff38ca12b4568a61d8ce5b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00041.html">Common::JString</a> &amp;&#160;</td>
          <td class="paramname"><em>ipAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nByte&#160;</td>
          <td class="paramname"><em>appID</em>[Internal::InternalProperties::APP_NAME_LENGTH] = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function starts establishing a connection to a <a class="el" href="a00276.html">Photon</a> server. The servers response will arrive in <a class="el" href="a00056.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a>.</p>
<p>The connection is successfully established when the <a class="el" href="a00276.html">Photon</a> client received a valid answer from the server. Connection fails when a network error occurs or when server is not responding. The actual result of connection is returning through the Listener::onStatusChanged() callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipAddr</td><td>Null terminated string containing IP address or domain name and optionally a port of server to connect. Should be in usual format\: "address[\:port]", for example\: "192.168.0.1\:5055" or "udp.gameserver.com". If no port is given, 5055 port will be used by default. </td></tr>
    <tr><td class="paramname">appID</td><td>Pointer to a nByte[APP_NAME_LENGTH] (last nByte must be '0') with the appID (default\: NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if it could successfully start establishing a connection (the result will be passed in the callback function in this case) or false, if an error occurred and the connection could not be established (the callback function will not be called then). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect()</a> </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00057_a3b7744e8ff38ca12b4568a61d8ce5b42_cgraph.gif" border="0" usemap="#a00057_a3b7744e8ff38ca12b4568a61d8ce5b42_cgraph" alt=""/></div>
<map name="a00057_a3b7744e8ff38ca12b4568a61d8ce5b42_cgraph" id="a00057_a3b7744e8ff38ca12b4568a61d8ce5b42_cgraph">
<area shape="rect" id="node2" href="a00041.html#aaccf5f4951fcdd522f35096a53ffe8d1" title="ExitGames::Common::\lJString::cstr" alt="" coords="112,5,240,43"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a888a5acf1fe3a8902f7cb2f5039cb334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void disconnect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initiates the disconnection from the <a class="el" href="a00276.html">Photon</a> server. The servers response will arrive in <a class="el" href="a00056.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a>.</p>
<p>This function generates a disconnection request that will be sent to the <a class="el" href="a00276.html">Photon</a> server. If the disconnection is completed successfully, the <a class="el" href="a00056.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a> callback will be called, with a statusCode of SC_DISCONNECT.</p>
<p>Disconnecting will also leave the joined game (if any) and trigger the respective event for the remaining players. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a3b7744e8ff38ca12b4568a61d8ce5b42">connect()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="a00029.html#a888a5acf1fe3a8902f7cb2f5039cb334">Client</a>.</p>

</div>
</div>
<a class="anchor" id="ac66e8bb0fdc525c5e250092c35343a2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void service </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dispatchIncomingCommands</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function executes the <a class="el" href="a00057.html">PhotonPeer</a> internal processes. Call this regularly!</p>
<p>This function is meant to be called frequently, like once per gameloop. It handles the internal calls for keeping the <a class="el" href="a00057.html">PhotonPeer</a> communication alive, and will take care of sending all local outgoing acknowledgements and messages, as well as dispatching incoming messages to the application, firing the corresponding callbacks. Internally PhotonPeer_service() calls the following functions: 1. <a class="el" href="a00057.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> 2. <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> (called withing a loop until all incoming commands have been dispatched.) 3. <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a></p>
<p><a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is provided for convenience. If you need to tweak the performance, you can ignore <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> and call its three subfunctions directly with individual time intervals, to gain more control over the internal communication process. For instance, calling <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> more rarely will result in less packets to be generated, as more commands will be accumulated into a single packet. See <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> for more information on efficiency.</p>
<p>For situations where you want to keep the connection alive, but can't process incoming messages (e.g. when loading ingame data), you can temporarily pass false for dispatchIncomingCommands to skip the calls to <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a>. Incoming commands will be store in the incoming queue until they are dispatched again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dispatchIncomingCommands</td><td>true = <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> will be called; false = <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> won't be called, default is true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab29567202b6f36cf6805209c2299d912"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serviceBasic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes care of exchanging data with the system's network layer.</p>
<p>You only need to call this function in case you choose not to use <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>, but call the subfunctions of <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> directly. Please see the documentation of <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> for more information.</p>
<p><a class="el" href="a00057.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> is called from within <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>. If you decide not to use <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a>, then <a class="el" href="a00057.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> needs to be called frequently, like once per game loop. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3c1268775eba0cfe2b6f7e309a27e2fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool opCustom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00053.html">OperationRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>operationRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendReliable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nByte&#160;</td>
          <td class="paramname"><em>channelID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encrypt</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends a custom operation to a custom Server, using reliable or unreliable <a class="el" href="a00276.html">Photon</a> transmission.</p>
<p>Allows the client to send a custom operation to the <a class="el" href="a00276.html">Photon</a> server (which has to be modified accordingly). The Server can be extended and modified for special purposes like server side collision detection or a consistent world.</p>
<p>You need to be connected (see <a class="el" href="a00057.html#a3b7744e8ff38ca12b4568a61d8ce5b42">connect()</a>) prior to calling <a class="el" href="a00057.html#a3c1268775eba0cfe2b6f7e309a27e2fd">opCustom()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operationRequest</td><td>holds the payload of the operation </td></tr>
    <tr><td class="paramname">sendReliable</td><td>= operation will be sent reliably; false = no resend in case of packet loss - will be ignored, when not using udp as protocol </td></tr>
    <tr><td class="paramname">channelID</td><td>the logical channel, default is 0. See <a class="el" href="a00020.html">Fragmentation and Channels</a> for more information. </td></tr>
    <tr><td class="paramname">encrypt</td><td>true = encrypt message; false = no encryption </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if successful, false otherwise </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>LitePeer::opRaiseEvent() </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="a00057_a3c1268775eba0cfe2b6f7e309a27e2fd_icgraph.gif" border="0" usemap="#a00057_a3c1268775eba0cfe2b6f7e309a27e2fd_icgraph" alt=""/></div>
<map name="a00057_a3c1268775eba0cfe2b6f7e309a27e2fd_icgraph" id="a00057_a3c1268775eba0cfe2b6f7e309a27e2fd_icgraph">
<area shape="rect" id="node2" href="a00046.html#aa3c67ad2f68b154c4fe37ef12737b6f9" title="ExitGames::Lite::LitePeer\l::opJoin" alt="" coords="125,5,267,43"/><area shape="rect" id="node3" href="a00046.html#ab895dbaac2028a5551b02a8fcbcf662a" title="ExitGames::Lite::LitePeer\l::opLeave" alt="" coords="125,67,267,104"/><area shape="rect" id="node4" href="a00046.html#a9c8292c06d60a6550f62f001771f0b93" title="ExitGames::Lite::LitePeer\l::opSetPropertiesOfActor" alt="" coords="125,128,267,165"/><area shape="rect" id="node5" href="a00046.html#ad01fbf8515131d8f9734fa8f3e10b96e" title="ExitGames::Lite::LitePeer\l::opSetPropertiesOfGame" alt="" coords="124,189,268,227"/><area shape="rect" id="node6" href="a00046.html#a31456fbb3ccb78af5ad978463a8ee26c" title="ExitGames::Lite::LitePeer\l::opGetProperties" alt="" coords="125,251,267,288"/><area shape="rect" id="node7" href="a00046.html#a7ff3511faee7df4cfd48f8cba05be3c2" title="ExitGames::Lite::LitePeer\l::opGetPropertiesOfActor" alt="" coords="125,312,267,349"/><area shape="rect" id="node8" href="a00046.html#ae994380b97ced6d96f0ed9b8e0582877" title="ExitGames::Lite::LitePeer\l::opGetPropertiesOfGame" alt="" coords="123,373,269,411"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8c40c416f4c106eaa3c0d21b5d1a440e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sendOutgoingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function initiates the transmission of outgoing commands.</p>
<p>Any <a class="el" href="a00276.html">Photon</a> function that generates messages will store these messages as a "command" in an outgoing queue for later transmission. Commands can either be explicitly created operations generated for example by <a class="el" href="a00057.html#a3c1268775eba0cfe2b6f7e309a27e2fd">opCustom()</a> or LitePeer::opRaiseEvent() or internally generated messages like acknowledgements for reliable messages from other players. <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> will initiate the data transmission by passing the outgoing commands to the system's sockets for immediate transmission.</p>
<p>In case of UDP <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> will also split the commands into multiple packets if needed and/of aggregate multiple commands together into one packet, if possible. Because of the latter calling sendOutgoingcommands() more rarely will result in less overhead, as there will be fewer packets for the clients to be sent and processed. The underlying platform can also limit the frequency in which outgoing packets can be sent and received. The downside of lower sending frequencies is a higher latency, until messages are exchanged and acknowledged, which may lead to a jerky gameplay.</p>
<p>To help you keeping track of the incoming and outgoing queues at development time and adjust your sending frequency, there will be a warning message sent to your CB_DEBUG_RETURN if a queue has exceeded the warning threshold as #defined in Constants.h (WARNING_THRESHOLD_QUEUE_OUTGOING, WARNING_THRESHOLD_QUEUE_INCOMING) </p>
<dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a00057.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly , when you use <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> and <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> directly instead.</dd></dl>
<p>Usually you don't have to call <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> this explicitly, as this is done within <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">PhotonPeer::service()</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">PhotonPeer::service()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4be00ecc71ec66c70629a9064d397d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool dispatchIncomingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for incoming commands waiting in the queue, and dispatches a single command to the application.</p>
<p>Dispatching means, that if the command is an operation response or an event, the callback function will be called (<a class="el" href="a00056.html#a03ff8cb4a6f605668586756cb6a113c7">PhotonListener::onOperationResponse()</a> or <a class="el" href="a00056.html#aebac55de19a14f226016bee9dc2125b1">PhotonListener::onEvent()</a>). <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> will also take care of generating and queuing acknowledgments for incoming reliable commands. Please note that this function will only dispatch one command per all. If you want to dispatch every single command which is waiting in the queue, call dipatchIncomingCommands() within a while loop, until its return code is false. </p>
<dl class="section note"><dt>Note</dt><dd>While <a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> is calling <a class="el" href="a00057.html#ab29567202b6f36cf6805209c2299d912">serviceBasic()</a> implicitly, you will have to regularly call it yourself explictly, when you use <a class="el" href="a00057.html#a8c40c416f4c106eaa3c0d21b5d1a440e">sendOutgoingCommands()</a> and <a class="el" href="a00057.html#a4be00ecc71ec66c70629a9064d397d2b">dispatchIncomingCommands()</a> directly instead. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if it has successfully dispatched a command, false otherwise (for example, when there has not been any command left in the queue, waiting for dispatching). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ac66e8bb0fdc525c5e250092c35343a2d">service()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a65ac22c1480ba011cf646db5a1038f63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool establishEncryption </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function creates a public key for this client and exchanges it with the server.</p>
<p>If <a class="el" href="a00057.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a> returns true, then <a class="el" href="a00276.html">Photon</a> will inform you about the successfull establishment or a failure by calling <a class="el" href="a00056.html#a762c08d3437006f3da1165e296bb52b3">PhotonListener::onStatusChanged()</a> with the statusCode beeing either SC_ENCRYPTION_ESTABLISHED or SC_ENCRYPTION_FAILED_TO_ESTABLISH </p>
<dl class="section return"><dt>Returns</dt><dd>true if encryption has been successfully initiated, false otherwise. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#af82e5be376f122cd0694474a2bf30df3">getIsEncryptionAvailable()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2e6e2243583f7cf42b8123e068302e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fetchServerTimestamp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This will fetch the server's timestamp and update the approximation for <a class="el" href="a00057.html#a0d497df1e1e3189833ea9a92a94e4ab8">getServerTime()</a> and <a class="el" href="a00057.html#a6fa4e468a3ebed107a6963ae1e15f244">getServerTimeOffset()</a>.</p>
<p>The server time approximation will NOT become more accurate by repeated calls. Accuracy currently depends on a single roundtrip which is done as fast as possible.</p>
<p>The command used for this is immediately acknowledged by the server. This makes sure the roundtriptime is low and the timestamp + roundtriptime / 2 is close to the original value. </p>

</div>
</div>
<a class="anchor" id="ae114d96824d1db8e0411453b737d0c50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00056.html">PhotonListener</a> * getListener </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the application's implementation of the Listener callback interface, as passed to the constructor of <a class="el" href="a00057.html">PhotonPeer</a>. </p>

</div>
</div>
<a class="anchor" id="a6fa4e468a3ebed107a6963ae1e15f244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getServerTimeOffset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the difference between the local uptime and the <a class="el" href="a00276.html">Photon</a> Server's system time.</p>
<p>In real-time games it's often useful to relate game events to a global common timeline, that's valid for all players and independent from derivations throughout the clients' system times. The <a class="el" href="a00276.html">Photon</a> Server's System Time can serve as this reference time. The serverTimeOffset represents the difference between the client's local system time and the <a class="el" href="a00276.html">Photon</a> server's system time.</p>
<p>ServerTime = serverTimeOffset + GETTIMEMS()</p>
<p>The serverTimeOffset is fetched shortly after connect by <a class="el" href="a00276.html">Photon</a>. Use GETTIMEMS() to get your local time in ms. You can let <a class="el" href="a00276.html">Photon</a> refetch the offset by calling <a class="el" href="a00057.html#ab2e6e2243583f7cf42b8123e068302e9">fetchServerTimestamp()</a>. The ServerTimeOffset will be 0 until shortly after initial connect. </p>

</div>
</div>
<a class="anchor" id="a0d497df1e1e3189833ea9a92a94e4ab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getServerTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the <a class="el" href="a00276.html">Photon</a> Server's system time.</p>
<p>see <a class="el" href="a00057.html#a6fa4e468a3ebed107a6963ae1e15f244">getServerTimeOffset()</a> </p>

</div>
</div>
<a class="anchor" id="a2c380f06cc1a08a040b29043504ee073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesOut </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of outgoing bytes transmitted by this <a class="el" href="a00057.html">PhotonPeer</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the total number of outgoing bytes </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ac51ec2106d45c47771b9623214a53765">getBytesIn()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac51ec2106d45c47771b9623214a53765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesIn </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of incoming bytes received by this <a class="el" href="a00057.html">PhotonPeer</a> object. </p>
<dl class="section return"><dt>Returns</dt><dd>the total number of received bytes </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a2c380f06cc1a08a040b29043504ee073">getBytesOut()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaa2341495102d474e47dfa8352cac466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PeerState::PeerState getPeerState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current state of the <a class="el" href="a00057.html">PhotonPeer</a> object</p>
<p>The state of the <a class="el" href="a00057.html">PhotonPeer</a> object is changed internally upon connection and disconnection, and will be one of the values of the <a class="el" href="a00285.html">PeerState</a> enum. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a3b7744e8ff38ca12b4568a61d8ce5b42">connect()</a>, <a class="el" href="a00057.html#a888a5acf1fe3a8902f7cb2f5039cb334">disconnect()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4b1062ff9979a3f5de11edb7432e954a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSentCountAllowance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of resend retries before a peer is considered lost/disconnected.</p>
<p>This is udp specific and will always return 0 for other protocols. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ae75b3c4ebd0d1c85b9455cd7c97c85f8">setSentCountAllowance()</a> <a class="el" href="a00057.html#ab6bdf2648a8ccfd9c83e0641b5663903">getDisconnectTimeout()</a> <a class="el" href="a00057.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae75b3c4ebd0d1c85b9455cd7c97c85f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSentCountAllowance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sentCountAllowance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the number of re-send retries before a peer is considered lost/disconnected.</p>
<p>This is udp specific and will do nothing at all for other protocols. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sentCountAllowance</td><td>the new number of re/-send retries before a peer is considered lost/disconnected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a4b1062ff9979a3f5de11edb7432e954a">getSentCountAllowance()</a> <a class="el" href="a00057.html#ab6bdf2648a8ccfd9c83e0641b5663903">getDisconnectTimeout()</a> <a class="el" href="a00057.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a43122c10ff52a0a6b227c443b49671bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getTimePingInterval </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time threshold in milliseconds since the last reliable command, before a ping will be sent. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ab96b54d2894633bf699bdf5b407bb486">setTimePingInterval()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab96b54d2894633bf699bdf5b407bb486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTimePingInterval </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timePingInterval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the time threshold in milliseconds since the last reliable command, before a ping will be sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timePingInterval</td><td>time threshold in milliseconds since the last reliable command, before a ping will be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a43122c10ff52a0a6b227c443b49671bd">getTimePingInterval()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d58f9f28efef342eb2e6b5e90babc95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRoundTripTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time in milliseconds until a reliable command is acknowledged by the server.</p>
<p>This is, what is commonly called a ping time or just a ping. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a45fdc08e49473ab212a337a2602f01fe">getRoundTripTimeVariance()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a45fdc08e49473ab212a337a2602f01fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getRoundTripTimeVariance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the variance of the roundtrip time in milliseconds. Gives a hint about how much the net latency is varying. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a3d58f9f28efef342eb2e6b5e90babc95">getRoundTripTime()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a164f59d83f8921f0466a666cb4db3eaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00248.html#ab658e6d84759440dbf3c890446075395">DebugLevel::DebugLevel</a> getDebugOutputLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Returns the current level of debug information that's passed on to <a class="el" href="a00027.html#ab4b256b4d717b7d8c142055fbcc9e6c6">BaseListener::debugReturn()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>In release builds all calls to <a class="el" href="a00027.html#ab4b256b4d717b7d8c142055fbcc9e6c6">BaseListener::debugReturn()</a> are removed for maximum performance. The debug output only effects debug builds. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>one of the values in <a class="el" href="a00248.html">DebugLevel</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00047.html#a8e11cbc98933d6a0687ffbca71f8c4c4">setDebugOutputLevel()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="abef1ecf21b7651217c62b279f879cc15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setDebugOutputLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00248.html#ab658e6d84759440dbf3c890446075395">Common::DebugLevel::DebugLevel</a>&#160;</td>
          <td class="paramname"><em>debugLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Sets the current level of debug information that's passed on to <a class="el" href="a00027.html#ab4b256b4d717b7d8c142055fbcc9e6c6">BaseListener::debugReturn()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>In release builds all calls to <a class="el" href="a00027.html#ab4b256b4d717b7d8c142055fbcc9e6c6">BaseListener::debugReturn()</a> are removed for maximum performance. The debug output only effects debug builds. Therefor in release builds this function does nothing at all except immediately and always returning false. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">debugLevel</td><td>one of the values in <a class="el" href="a00248.html">DebugLevel</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the new debug level has been set correctly, false otherwise. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00047.html#a164f59d83f8921f0466a666cb4db3eaf">getDebugOutputLevel()</a> </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a85b40e4d8e9dd59483904727618c8a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getIncomingReliableCommandsCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of reliable commands currently waiting in the incoming queues of all channels. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of reliable commands, or -1 if not connected. </dd></dl>

</div>
</div>
<a class="anchor" id="a0dae9746fea1efa33a84167808c59962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short getPeerId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this peer's ID as assigned by the server. Will be -1, if not connected. </p>

</div>
</div>
<a class="anchor" id="ab6bdf2648a8ccfd9c83e0641b5663903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getDisconnectTimeout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum time interval in milliseconds for doing resend retries before a peer is considered lost/disconnected. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a9f9e8b780e386121f1b33b3f1c95c123">setDisconnectTimeout()</a> <a class="el" href="a00057.html#a4b1062ff9979a3f5de11edb7432e954a">getSentCountAllowance()</a> <a class="el" href="a00057.html#ae75b3c4ebd0d1c85b9455cd7c97c85f8">setSentCountAllowance()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9e8b780e386121f1b33b3f1c95c123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDisconnectTimeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>disconnectTimeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum time ins milliseconds for making re-send retries before a peer is considered lost/disconnected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disconnectTimeout</td><td>resend max time in ms before a peer is considered lost/disconnected </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#ab6bdf2648a8ccfd9c83e0641b5663903">getDisconnectTimeout()</a> <a class="el" href="a00057.html#a4b1062ff9979a3f5de11edb7432e954a">getSentCountAllowance()</a> <a class="el" href="a00057.html#ae75b3c4ebd0d1c85b9455cd7c97c85f8">setSentCountAllowance()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9de704871bf246a9f2a074fc524090c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getQueuedIncomingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of queued incoming commands in all channels or -1 if not connected </dd></dl>

</div>
</div>
<a class="anchor" id="a1b26feaa1adf2eb401755cc181567ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getQueuedOutgoingCommands </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of queued outgoing commands in all channels or -1 if not connected </dd></dl>

</div>
</div>
<a class="anchor" id="ae1b12d1666e4c44dc9301a1c3de443bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00041.html">JString</a> getServerAddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the IP or url of the server, to which the peer is connected to </dd></dl>

</div>
</div>
<a class="anchor" id="af82e5be376f122cd0694474a2bf30df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getIsEncryptionAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this peer's encryption availability status. True if encryption is available, false otherwise. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00057.html#a65ac22c1480ba011cf646db5a1038f63">establishEncryption()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10359924120048ca6281db6ed9dda97d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short getPeerCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the count of peers, which have been initialized since the start of the application. Interesting mainly for debugging purposes. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00246.html">ExitGames</a></li><li class="navelem"><a class="el" href="a00276.html">Photon</a></li><li class="navelem"><a class="el" href="a00057.html">PhotonPeer</a></li>
    <li class="footer">Generated on Thu Dec 5 2013 17:19:17 for Exit Games Photon C++ Client Library by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
